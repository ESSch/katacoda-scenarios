## Обеспечение фактического соответствия CloudNative
Здесь и далее Вам потребуется изменить приложение и конфиг (изменения сохраняются сразу), и применить изменения, для этого:
1. `kubectl delete configmap app`{{execute T1}}
2. `kubectl create configmap app --from-file=/root/exercise/server.js --from-file=/root/exercise/front.html`{{execute T1}}
3. `kubectl delete -f /root/exercise/app.yaml`{{execute T1}}
4. `kubectl apply  -f /root/exercise/app.yaml`{{execute T1}}

Для фактической проверки убедимся в работе приложения. Дождитесь старта контейнера `kubectl get events -w --field-selector involvedObject.kind=Pod`{{execute T4}}: `Scheduled -> Pulled -> Created -> Started`. Так как у нас сейчас нет эндпойтов, проложение будет признано нерабочим и буедт попытка запустить повторно: `-> Unhealthy -> Killing -> Pulled -> Created -> Started`. 

Раскоментируйте эндпойнты в приложении (`server.js`{{open}}) и примените изменения, как узказано выше. Теперь у нас запущено приложение и можно перейти по ссылке http://[[HOST_SUBDOMAIN]]-30333-[[KATACODA_HOST]].environments.katacoda.com/, дождитесь старта приложения и посмотрите реакцию приложения `kubectl logs $(kubectl get pod -l app=app -o jsonpath={@.items[0].metadata.name}) -f`{{execute T5}}.

Проверка выполнения RN-2.2. Сейчас при удалении `kubectl exec $(kubectl get pods -l app=app -o jsonpath={.items[0].metadata.name}) mv /app/front.html /tmp/`{{execute T1}} статического файла эндпойнт liveness отвечает успехом, что приводит к получению трафику при фактически невозможности выполнять больше свою функцию приложением. Аналогичным кейсом можно считать, когда в приложении прописано соединение с базой данных и оно не может сейчас его установить, а ожидание и повторы в приложении не предусмотрено. Другим кейсом может быть равёртывании приложения, если в коде ошибка - в таком случае CD по перезагружающемуся контейнеру сможет определить неисправность и откатить образ на предыдущий в imageStream. Измените эндпойнт liveness так, чтобы при отсутствии файла приложение было бы пересоздано, например, добавив `status = fs.existsSync('front.html') ? 200 : 500`.

Проверка выполнения NE-3.3. Рассмотрим кейс, когда приложение не может обрабатывать временно запросы, например, когда в связи с временной недоступностью из-за внутренних или внешних причин. В этом случае сервис лучше вывести из под нагрузки, чтобы нагрузка распределялась на доступные реплики. Но, не стоит использовать пробу для балансировки нагрузки - для этого есть Istio по фиксации нагрузки на реплику и балансировка по количеству подключений "LEAST_CONN".

Проверка выполнения NE-3.4. Наше приложение простое и написано на NodeJS, поэтому старт его занимает до нескольких секунд, которые можно установить задержкой в liveness и readiness. Если это не так, то и разброс может быть большим, тогда лучше использовать пробу, например, что процесс приложения поднялся с помощью startup пробы. Более подробно мы рассмотрим в [уроке по тяжёлым приложениям нашего курса](https://www.katacoda.com/essch/scenarios/exercise2).  