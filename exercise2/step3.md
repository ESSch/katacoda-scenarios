## Обеспечение фактического соответствия CloudNative
Здесь и далее Вам потребуется изменить приложение и конфигурационный файл (изменения сохраняются сразу), и применить изменения, для этого:
1. `kubectl delete configmap app`{{execute T1}}

2. `kubectl create configmap app --from-file=/root/exercise/server.js --from-file=/root/exercise/front.html`{{execute T1}}

3. `kubectl delete -f /root/exercise/app.yaml`{{execute T1}}

4. `kubectl apply  -f /root/exercise/app.yaml`{{execute T1}}

Для фактической проверки убедимся в работе приложения. Дождитесь старта контейнера `kubectl get events -w --field-selector involvedObject.kind=Pod`{{execute T4}}: `Scheduled -> Pulled -> Created -> Started`. Так как у нас сейчас нет эндпойтов, проложение будет признано нерабочим и будет попытка запустить повторно: `-> Unhealthy -> Killing -> Pulled -> Created -> Started`. 

Раскоментируйте эндпойнты в приложении (`server.js`{{open}}) и примените изменения, как указанно выше. Теперь у нас запущено приложение и можно перейти по ссылке http://[[HOST_SUBDOMAIN]]-30333-[[KATACODA_HOST]].environments.katacoda.com/. Дождитесь старта приложения и посмотрите реакцию приложения: `kubectl logs $(kubectl get pod -l app=app -o jsonpath={@.items[0].metadata.name}) -f`{{execute T5}}.

Проверка выполнения RN-2.2. Сейчас при удалении `bash /root/exercise/update.sh; kubectl exec $(kubectl get pods -l app=app -o jsonpath={.items[0].metadata.name}) mv /app/front.html /tmp/`{{execute T1}} статического файла приложение теряет свой основное назначение - показывать пользователям статический файл. При обращению к эндпойнтам liveness и readeness - они отвечает успехом. Успех readeness приводит к тому, что трафик поступает на неработоспособное приложение, а не будет перенаправлено сервисом OpenShift на другие реплими. Успех readeness приводит к тому, что контейнер не будет убит, когда решением данной проблемы явлетя пересоздание контейнера с нуля. Изменим эндпойнт liveness так, чтобы при отсутствии файла приложение он отдавал статус 500: `sed -i "/\/liveness/astatus = fs.existsSync('front.html') ? 200 : 500;" /root/exercise/server.js`{{execute T1}}

Проверка выполнения NE-3.3. Рассмотрим кейс, когда приложение не может обрабатывать временно запросы, например, когда в связи с временной недоступностью из-за внутренних или внешних причин. В этом случае сервис лучше вывести из под нагрузки, чтобы нагрузка распределялась на доступные реплики. Но, не стоит использовать пробу для управления балансировкой нагрузки. Для этого переведите пробу readiness на входящий трафик. 

Проверка выполнения NE-3.4. Наше приложение простое и написано на NodeJS, поэтому старт его занимает до нескольких секунд, которые можно установить задержкой в liveness и readiness. Если это не так, то и разброс может быть большим, тогда лучше использовать пробу, например, что процесс приложения поднялся с помощью startup пробы. Более подробно мы рассмотрим в [уроке по тяжёлым приложениям нашего курса](https://www.katacoda.com/essch/scenarios/exercise2).
